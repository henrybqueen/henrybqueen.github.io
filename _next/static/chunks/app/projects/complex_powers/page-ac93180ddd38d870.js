(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[639],{6125:function(e,n,t){Promise.resolve().then(t.bind(t,4091))},4091:function(e,n,t){"use strict";var o=t(7437),r=t(2265),a=t(3149),l=t(7776),c=t(5452);n.default=()=>{let e=(0,r.useRef)(null),[n,t]=(0,r.useState)(0),i=function(e,n){let t=new Float32Array(482403),o=.005,r=0;for(let n=-e;n<=e;n++)for(let a=-e;a<=e;a++)t[r]=n*o,t[r+1]=a*o,t[r+2]=0,r+=3;return t}(200,0),s=(0,r.useRef)(null),{power:u}=(0,c.M4)({power:{value:{x:1,y:0}}}),f=(0,r.useMemo)(()=>({p:{value:new l.Vector2(u.x,u.y)},scale:{value:0}}),[]);return(0,r.useEffect)(()=>{s.current&&(s.current.uniforms.p.value.set(u.x,u.y),s.current.uniforms.scale.value=n)},[u,n]),(0,o.jsxs)(a.Xz,{className:"size-full",orthographic:!0,camera:{near:0,position:[0,0,1],left:-1,right:1,top:1,bottom:-1},ref:e,onWheel:n=>(function(n){if(e.current){let o=e.current.getBoundingClientRect(),r=n.clientX-o.left,a=n.clientY-o.top,l=(2*r-o.width)/o.width,c=(-2*a+o.height)/o.height;console.log("Scroll delta: ".concat(n.deltaY)),console.log("normalized coordinates: (".concat(l,", ").concat(c,")")),t(e=>e+.005*n.deltaY)}})(n),children:[(0,o.jsx)("ambientLight",{intensity:Math.PI/2}),(0,o.jsx)("spotLight",{position:[10,10,10],angle:.15,penumbra:1,decay:0,intensity:Math.PI}),(0,o.jsxs)("points",{children:[(0,o.jsx)("bufferGeometry",{children:(0,o.jsx)("bufferAttribute",{attach:"attributes-position",array:i,count:160801,itemSize:3})}),(0,o.jsx)("shaderMaterial",{vertexShader:"\nuniform vec2 p;\nuniform float scale;\n\nvarying vec3 vColor;\n\nvec2 complexPower(vec2 q, vec2 p) {\n    float a = q.x;\n    float b = q.y;\n    float c = p.x;\n    float d = p.y;\n    \n    // Convert q to polar form: r * e^(i*theta)\n    float r = length(q);\n    float theta = atan(b, a);\n    \n    // Compute the power in polar form: (r^c) * e^(i*(c*theta + d*ln(r)))\n    float log_r = log(r);\n    float arg = c * theta + d * log_r;\n    float exp_c_log_r = exp(c * log_r - d * theta);\n    \n    // Convert back to rectangular form\n    return vec2(exp_c_log_r * cos(arg), exp_c_log_r * sin(arg));\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec2 q = position.xy;\n    vec2 result = exp(scale) * complexPower(q, p);\n\n    float angle = atan(q.y, q.x);\n    float hue = (angle / (2.0 * 3.141592653589793)) + 0.5; // normalize to [0, 1]\n    vColor = hsv2rgb(vec3(hue, 1.0, 1.0));\n\n    gl_Position = vec4(result, 0.0, 1.0);\n    gl_PointSize = 2.0; // Adjust this value to change the size of the points\n}\n",fragmentShader:"\nvarying vec3 vColor;\n\nvoid main() {\n    gl_FragColor = vec4(vColor, 1.0); // RGBA\n}\n",uniforms:f,side:l.DoubleSide,ref:s})]})]})}}},function(e){e.O(0,[689,149,452,971,23,744],function(){return e(e.s=6125)}),_N_E=e.O()}]);